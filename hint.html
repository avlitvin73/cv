<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	<code>
    import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { HttpEvent, HttpHandler, HttpRequest } from '@angular/common/http';
import { Observable } from 'rxjs';
import { SessionService } from '@services/session.service';
import { AuthInterceptor } from './auth.interceptor';
import {
    SECURITY_CANVAS,
    SECURITY_WEB_GL,
    ACCESS_TOKEN,
    INTERCEPTOR_SKIP_HEADER,
} from '../constants';

describe('AuthInterceptor', () => {
    let interceptor: AuthInterceptor;
    let httpMock: HttpTestingController;
    let sessionService: SessionService;

    beforeEach(() => {
        TestBed.configureTestingModule({
            imports: [HttpClientTestingModule],
            providers: [AuthInterceptor, SessionService],
        });
        interceptor = TestBed.inject(AuthInterceptor);
        httpMock = TestBed.inject(HttpTestingController);
        sessionService = TestBed.inject(SessionService);
    });

    afterEach(() => {
        httpMock.verify();
    });

    it('should add authorization header with access token if skip header is not present', () => {
        const token = 'test-token';
        spyOn(sessionService, 'load').and.returnValue(token);

        const req = new HttpRequest<any>('GET', 'test-url');
        const next: HttpHandler = {
            handle: (req: HttpRequest<any>): Observable<HttpEvent<any>> => {
                expect(req.headers.get('Authorization')).toBe(Bearer ${token});
                return new Observable();
            },
        };

        interceptor.intercept(req, next);
        const mockReq = httpMock.expectOne('test-url');
        expect(mockReq.request.headers.get('Authorization')).toBe(Bearer ${token});
        mockReq.flush({});
    });

    it('should not add authorization header if skip header is present', () => {
        const token = 'test-token';
        spyOn(sessionService, 'load').and.returnValue(token);

        const req = new HttpRequest<any>('GET', 'test-url', null, { headers: { [INTERCEPTOR_SKIP_HEADER]: 'true' } });
        const next: HttpHandler = {
            handle: (req: HttpRequest<any>): Observable<HttpEvent<any>> => {
                expect(req.headers.get('Authorization')).toBeNull();
                return new Observable();
            },
        };

        interceptor.intercept(req, next);
        const mockReq = httpMock.expectOne('test-url');
        expect(mockReq.request.headers.get('Authorization')).toBeNull();
        mockReq.flush({});
    });

    it('should add security markers to request body', () => {
        localStorage.setItem(SECURITY_CANVAS, 'test-canvas');
        localStorage.setItem(SECURITY_WEB_GL, 'test-webgl');

        const req = new HttpRequest<any>('POST', 'test-url', { data: 'test-data' });
        const next: HttpHandler = {
            handle: (req: HttpRequest<any>): Observable<HttpEvent<any>> => {
                expect(req.body.securityMarkers).toEqual({
                    securityCanvas: 'test-canvas',
                    securitywebGL: 'test-webgl',
                });
                return new Observable();
            },
        };

        interceptor.intercept(req, next);
        const mockReq = httpMock.expectOne('test-url');
        expect(mockReq.request.body.securityMarkers).toEqual({
            securityCanvas: 'test-canvas',
            securitywebGL: 'test-webgl',
        });
        mockReq.flush({});
    });
});

  </code>
</body>
</html>
