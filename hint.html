<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	<code>
		<pre>
			it('should add authorization header with access token if skip header is not present', () => {
  const accessToken = 'testToken';
  spyOn(sessionService, 'load').mockReturnValue(accessToken);

  let response: any = null;
  interceptor.intercept(httpRequest, next).subscribe(res => {
    response = res;
  });

  const req = httpMock.expectOne(httpRequest.url);
  expect(req.request.headers.has('Authorization')).toBeTrue();
  expect(req.request.headers.get('Authorization')).toEqual(Bearer ${accessToken});

  req.flush(mockResponse);

  expect(response).toEqual(mockResponse);
});

it('should not add authorization header if skip header is present', () => {
  httpRequest = httpRequest.clone({
    headers: new HttpHeaders({ [INTERCEPTOR_SKIP_HEADER]: 'true' })
  });

  let response: any = null;
  spyOn(sessionService, 'load');
  interceptor.intercept(httpRequest, next).subscribe(res => {
    response = res;
  });

  const req = httpMock.expectOne(httpRequest.url);
  expect(req.request.headers.has('Authorization')).toBeFalse();

  req.flush(mockResponse);

  expect(response).toEqual(mockResponse);
});

it('should add security markers to request body', () => {
  spyOn(localStorage, 'getItem').and.callFake((key: string) => {
    if (key === SECURITY_CANVAS || key === SECURITY_WEB_GL) {
      return 'testMarker';
    }
    return null;
  });

  let response: any = null;
  interceptor.intercept(httpRequest, next).subscribe(res => {
    response = res;
  });

  const req = httpMock.expectOne(httpRequest.url);
  const requestBody = JSON.parse(req.request.body);
  expect(requestBody.securityMarkers).toEqual(['testMarker', 'testMarker']);

  req.flush(mockResponse);

  expect(response).toEqual(mockResponse);
});
		</pre>
  

  </code>
</body>
</html>
