<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	<code>
		<pre>
			it('should add authorization header with access token if skip header is not present', () => {
  const accessToken = 'testToken';
  spyOn(sessionService, 'load').mockReturnValue(accessToken);

  let response: any = null;
  interceptor.intercept(httpRequest, next).subscribe(res => {
    response = res;
  });

  const req = httpMock.expectOne(httpRequest.url);
  expect(req.request.headers.has('Authorization')).toBeTrue();
  expect(req.request.headers.get('Authorization')).toEqual(Bearer ${accessToken});

  req.flush(mockResponse);

  expect(response).toEqual(mockResponse);
});

it('should not add authorization header if skip header is present', () => {
  httpRequest = httpRequest.clone({
    headers: new HttpHeaders({ [INTERCEPTOR_SKIP_HEADER]: 'true' })
  });

  let response: any = null;
  spyOn(sessionService, 'load');
  interceptor.intercept(httpRequest, next).subscribe(res => {
    response = res;
  });

  const req = httpMock.expectOne(httpRequest.url);
  expect(req.request.headers.has('Authorization')).toBeFalse();

  req.flush(mockResponse);

  expect(response).toEqual(mockResponse);
});

it('should add security markers to request body', () => {
  spyOn(localStorage, 'getItem').and.callFake((key: string) => {
    if (key === SECURITY_CANVAS || key === SECURITY_WEB_GL) {
      return 'testMarker';
    }
    return null;
  });

  let response: any = null;
  interceptor.intercept(httpRequest, next).subscribe(res => {
    response = res;
  });

  const req = httpMock.expectOne(httpRequest.url);
  const requestBody = JSON.parse(req.request.body);
  expect(requestBody.securityMarkers).toEqual(['testMarker', 'testMarker']);

  req.flush(mockResponse);

  expect(response).toEqual(mockResponse);
});




			================
import { createHttpFactory, HttpMethod, SpectatorHttp } from '@ngneat/spectator/jest';
import { AuthInterceptor } from './auth.interceptor';
import { SessionService } from '@services/session.service';
import { of } from 'rxjs';

describe('AuthInterceptor', () => {
  let spectator: SpectatorHttp<AuthInterceptor>;
  let sessionService: SessionService;

  const createHttp = createHttpFactory({
    service: AuthInterceptor,
    providers: [
      {
        provide: SessionService,
        useValue: {
          load: jest.fn(() => 'token')
        }
      }
    ],
    mocks: [SessionService]
  });

  beforeEach(() => {
    spectator = createHttp();
    sessionService = spectator.inject(SessionService);
    localStorage.setItem('SECURITY_WEB_GL', 'webgl');
    localStorage.setItem('SECURITY_CANVAS', 'canvas');
  });

  afterEach(() => {
    localStorage.clear();
  });

  it('should add Authorization and securityMarkers headers to the request', () => {
    spectator.service.intercept(spectator.get('/api'), {
      handle: jest.fn(() => of(null))
    }).subscribe();

    const req = spectator.expectOne('/api', HttpMethod.GET);
    expect(req.request.headers.get('Authorization')).toBe('Bearer token');
    expect(req.request.body.securityMarkers).toEqual({
      securitywebGL: 'webgl',
      securityCanvas: 'canvas'
    });
  });
});
	
		
		
		
		
		=============


	  import { HttpTestingController, HttpClientTestingModule } from '@angular/common/http/testing';
import { TestBed } from '@angular/core/testing';
import { HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { AuthInterceptor } from './auth.interceptor';
import { SessionService } from '@services/session.service';

describe('AuthInterceptor', () => {
    let interceptor: AuthInterceptor;
    let sessionServiceMock: any;
    let httpMock: HttpTestingController;

    beforeEach(() => {
        sessionServiceMock = { load: jest.fn() };
        TestBed.configureTestingModule({
            imports: [HttpClientTestingModule],
            providers: [
                AuthInterceptor,
                { provide: SessionService, useValue: sessionServiceMock }
            ]
        });

        interceptor = TestBed.inject(AuthInterceptor);
        httpMock = TestBed.inject(HttpTestingController);
    });

    it('должен добавлять заголовок Authorization, когда токен присутствует', () => {
        const mockRequest = new HttpRequest('GET', 'https://example.com');
        const mockHandler: HttpHandler = {
            handle: jest.fn(() => of({} as HttpEvent<any>))
        };
        
        sessionServiceMock.load.mockReturnValue('fake-token');
        
        interceptor.intercept(mockRequest, mockHandler).subscribe();

        const expectedHeaders = { Authorization: 'Bearer fake-token' };
        const expectedRequest = mockRequest.clone({ setHeaders: expectedHeaders });

        expect(mockHandler.handle).toHaveBeenCalledWith(expectedRequest);
    });

    // Добавьте здесь больше тестов

    afterEach(() =>

        httpMock.verify();
    });
});

		
		
		
		
		
		
		
		
		
		
		
		</pre>
  

  </code>
</body>
</html>
